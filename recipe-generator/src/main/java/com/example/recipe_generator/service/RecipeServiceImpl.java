// RecipeServiceImpl.java
package com.example.recipe_generator.service;

import com.example.recipe_generator.dto.RecipeRequest;
import com.example.recipe_generator.dto.RecipeResponse;
import com.example.recipe_generator.integration.AiServiceClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors; // Add this import

@Service
public class RecipeServiceImpl implements RecipeService {
    private static final Logger logger = LoggerFactory.getLogger(RecipeServiceImpl.class);
    private final AiServiceClient aiServiceClient;

    @Autowired
    public RecipeServiceImpl(AiServiceClient aiServiceClient) {
        this.aiServiceClient = aiServiceClient;
    }

    @Override
    public RecipeResponse generateRecipe(RecipeRequest request) throws Exception {
        String prompt = buildPrompt(request);
        logger.info("Generated AI Prompt: {}", prompt);
        String aiGeneratedText;
        try {
            aiGeneratedText = aiServiceClient.getRecipeFromAi(prompt);
            logger.debug("Raw AI Response Text:\n{}", aiGeneratedText);
        } catch (Exception e) {
            logger.error("Error calling AI Service client: {}", e.getMessage(), e);
            throw new Exception("Failed to get recipe from AI service.", e);
        }
        try {
            RecipeResponse recipeResponse = parseAiResponse(aiGeneratedText);
            logger.info("Successfully parsed AI response for recipe: {}", recipeResponse.getRecipeName());
            return recipeResponse;
        } catch (Exception e) {
            logger.error("Error parsing AI response: {}", e.getMessage(), e);
            return RecipeResponse.builder()
                    .recipeName("Error Parsing Recipe")
                    .description("Could not parse the recipe generated by the AI.")
                    .requiredIngredients(Collections.emptyList())
                    .instructions(Collections.emptyList())
                    .notes("Parsing Error: " + e.getMessage())
                    .build();
        }
    }

    // ... rest of the code (buildPrompt, parseAiResponse, etc.) ...

    /**
     * Constructs the prompt string to be sent to the AI service.
     * This method contains the core "prompt engineering".
     *
     * @param request The user's request DTO.
     * @return A formatted prompt string.
     */
    private String buildPrompt(RecipeRequest request) {
        String ingredientsList = String.join(", ", request.getIngredients());
        String preference = request.getPreference() != null && !request.getPreference().trim().isEmpty()
                ? request.getPreference().trim()
                : "Any"; // Default preference if not specified or empty

        // --- Prompt Engineering ---
        // Be very specific about the desired output format. Using clear markers helps parsing.
        // Experiment with this prompt structure for best results with Gemini.
        return String.format(
                "Generate a complete recipe based on the following details:\n" +
                        "Available Ingredients: %s\n" +
                        "Dietary Preference: %s\n\n" +
                        "Please provide the output strictly in the following format, using the markers exactly as shown:\n\n" +
                        "Title: [Recipe Title Here]\n\n" +
                        "Description: [A brief, engaging description of the recipe.]\n\n" +
                        "Ingredients:\n" +
                        "- [Amount] [Unit] [Ingredient Name]\n" +
                        "- [Amount] [Unit] [Ingredient Name]\n" +
                        "[...list all necessary ingredients, including common ones like oil, salt, pepper if needed, derived from the available ingredients where possible]\n\n" +
                        "Instructions:\n" +
                        "1. [Step 1]\n" +
                        "2. [Step 2]\n" +
                        "[...list all steps clearly and concisely]\n\n" +
                        "Notes: [Optional: Add any relevant notes, tips, or variations here. If none, write 'None'.]\n\n" +
                        "Ensure you only use the provided markers (Title:, Description:, Ingredients:, Instructions:, Notes:) to structure the response.",
                ingredientsList, preference
        );
    }

    /**
     * Parses the raw text response from the AI into a structured RecipeResponse DTO.
     * This implementation relies on specific markers (e.g., "Title:", "Ingredients:")
     * being present in the AI's response, as requested in the prompt.
     *
     * IMPORTANT: This parsing logic might be fragile and may need refinement based
     * on the actual consistency of the AI's output. Consider using more robust
     * parsing techniques (like Regex with capturing groups) if this proves unreliable.
     *
     * @param aiText The raw text response from the AI service.
     * @return A populated RecipeResponse DTO.
     * @throws IllegalArgumentException if essential markers are missing.
     */
    private RecipeResponse parseAiResponse(String aiText) {
        if (aiText == null || aiText.trim().isEmpty()) {
            throw new IllegalArgumentException("Received empty or null response from AI.");
        }

        // Normalize line endings for consistent splitting
        String normalizedText = aiText.replace("\r\n", "\n");

        // --- Extract sections based on markers ---
        // We look for the text *between* markers or from a marker to the end.

        String title = extractSection(normalizedText, "Title:", "Description:");
        String description = extractSection(normalizedText, "Description:", "Ingredients:");
        String ingredientsBlock = extractSection(normalizedText, "Ingredients:", "Instructions:");
        String instructionsBlock = extractSection(normalizedText, "Instructions:", "Notes:");
        String notes = extractSection(normalizedText, "Notes:", null); // Extracts till the end

        // --- Process extracted blocks ---

        // Parse Ingredients list (simple line splitting, removing list markers)
        List<String> ingredientsList = parseListBlock(ingredientsBlock);

        // Parse Instructions list (simple line splitting, removing list markers)
        List<String> instructionsList = parseListBlock(instructionsBlock);

        // Basic validation - check if essential parts were found
        if (title.isEmpty() && description.isEmpty() && ingredientsList.isEmpty() && instructionsList.isEmpty()) {
            throw new IllegalArgumentException("Failed to parse AI response. Essential markers (Title, Description, Ingredients, Instructions) might be missing or the format is incorrect.");
        }


        return RecipeResponse.builder()
                .recipeName(title.isEmpty() ? "AI Generated Recipe (Untitled)" : title)
                .description(description)
                .requiredIngredients(ingredientsList)
                .instructions(instructionsList)
                .notes(notes.equalsIgnoreCase("None") ? "" : notes) // Handle "None" case for notes
                .build();
    }

    /**
     * Helper method to extract text between a start marker and an end marker.
     *
     * @param text The text to search within.
     * @param startMarker The starting marker (e.g., "Title:").
     * @param endMarker The ending marker (e.g., "Description:"). If null, extracts to the end.
     * @return The extracted text, trimmed. Returns empty string if start marker not found.
     */
    private String extractSection(String text, String startMarker, String endMarker) {
        int startIndex = text.indexOf(startMarker);
        if (startIndex == -1) {
            logger.warn("Start marker '{}' not found in AI response.", startMarker);
            return ""; // Marker not found
        }
        startIndex += startMarker.length(); // Move index past the marker

        int endIndex;
        if (endMarker != null) {
            endIndex = text.indexOf(endMarker, startIndex);
            if (endIndex == -1) {
                // If end marker isn't found, maybe take text until end of file? Or log warning?
                // Taking until end of file might grab too much if format is broken.
                // Let's try taking up to the end for Notes, but maybe not others.
                // For now, if end marker specified but not found, assume it goes to end (careful!)
                // Only really safe for the *last* expected marker (like Notes)
                if (!startMarker.equals("Notes:")) { // Be more strict for intermediate sections
                    logger.warn("End marker '{}' not found after start marker '{}'. Returning empty for section.", endMarker, startMarker);
                    return ""; // Or consider taking until end, but log warning
                }
                endIndex = text.length();
            }
        } else {
            // No end marker provided, extract till the end of the text
            endIndex = text.length();
        }

        if (endIndex <= startIndex) {
            logger.warn("End marker '{}' found before or at start marker '{}'.", endMarker, startMarker);
            return ""; // End marker is before start marker
        }

        return text.substring(startIndex, endIndex).trim();
    }


    /**
     * Helper method to parse a block of text assumed to be a list (like ingredients or instructions).
     * Splits by newline and cleans up common list prefixes (like '-', '*', '1.').
     *
     * @param block The block of text containing the list.
     * @return A List of strings, each representing a list item.
     */
    private List<String> parseListBlock(String block) {
        if (block == null || block.trim().isEmpty()) {
            return Collections.emptyList();
        }
        // Split by newline, trim whitespace, remove common list markers, filter empty lines
        return Arrays.stream(block.split("\\n")) // Split by newline
                .map(String::trim) // Trim whitespace
                .map(line -> line.replaceAll("^\\s*[-*]\\s*|^\\s*\\d+[.)]\\s*", "")) // Remove bullets/numbers
                .filter(line -> !line.isEmpty()) // Remove any empty lines resulting from splits or marker removal
                .collect(Collectors.toList());
    }
}